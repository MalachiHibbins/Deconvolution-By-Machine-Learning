%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Week 1 - PyTorch Fundamentals}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Deconvolution Using Machine Learning}
\date{Nov 19, 2025}
\release{}
\author{Malachi Hibbins}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Contents}
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Week 1 \sphinxhyphen{} PyTorch Fundamentals

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Week1/1PytorchTutorial::doc}]{\sphinxcrossref{PyTorch Tutorial}}}

\end{itemize}
\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Week 2 \sphinxhyphen{} Deblurring Methods

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Week2/12DFowierTransforms::doc}]{\sphinxcrossref{2D Fourier Transforms}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Week2/2ImageDebluring::doc}]{\sphinxcrossref{Image Deblurring}}}

\end{itemize}
\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Week 3 and 4 \sphinxhyphen{} Richardson and Lucy Algorithm

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Week3/1richardsonlucy::doc}]{\sphinxcrossref{Richardson\sphinxhyphen{}Lucy Algorithm}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Week3/2richardsonlucy::doc}]{\sphinxcrossref{Tuning Richardson\sphinxhyphen{}Lucy}}}

\end{itemize}
\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Week 5\sphinxhyphen{}8 \sphinxhyphen{} Neural Networks

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{Week7/MachineLearningFunction::doc}]{\sphinxcrossref{Neural Networks for Image De\sphinxhyphen{}noising}}}

\end{itemize}
\end{itemize}

\sphinxstepscope


\part{Week 1 \sphinxhyphen{} PyTorch Fundamentals}

\sphinxstepscope


\chapter{Learning Pytorch}
\label{\detokenize{Week1/1PytorchTutorial:learning-pytorch}}\label{\detokenize{Week1/1PytorchTutorial::doc}}
\sphinxAtStartPar
Pytorch is a machine learning library and will be used in this project to build and train neural networks. It is built on top of the tensor library \sphinxcode{\sphinxupquote{torch}}, which is a library for high performance numerical computing.


\section{Aims}
\label{\detokenize{Week1/1PytorchTutorial:aims}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Practice using and troubleshooting pytorch

\item {} 
\sphinxAtStartPar
Understand the advantages of using pytorch over numpy

\item {} 
\sphinxAtStartPar
Build a basic machine learning algorithm

\end{itemize}


\section{Tensors}
\label{\detokenize{Week1/1PytorchTutorial:tensors}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A specialized data structure very similar to numpy arrays

\item {} 
\sphinxAtStartPar
Similar to numpy arrays but can also run on the GPU as well as the CPU, meaning thousands of operations can be handled simultaneously. Making them a more suitable data structure for training neural networks.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{TLDR they are like numpy arrays but with the ability to run on high performance hardware}

\end{itemize}


\subsection{Basic Tensor Examples}
\label{\detokenize{Week1/1PytorchTutorial:basic-tensor-examples}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}torch\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} From 2d list}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{x\PYGZus{}data} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{tensor}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} From numpy array}
\PYG{n}{np\PYGZus{}array} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{x\PYGZus{}np} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{from\PYGZus{}numpy}\PYG{p}{(}\PYG{n}{np\PYGZus{}array}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Overides initial x\PYGZus{}data with the same shape but random values}

\PYG{n}{x\PYGZus{}rand} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{rand\PYGZus{}like}\PYG{p}{(}\PYG{n}{x\PYGZus{}data}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{float}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x\PYGZus{}rand}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tensor([[0.0394, 0.2424],
        [0.1560, 0.1370]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Loading a dataset}
\label{\detokenize{Week1/1PytorchTutorial:loading-a-dataset}}
\sphinxAtStartPar
Below is an example of how to load the Fasion\sphinxhyphen{}MINST dataset from TorchVision. The dataset contains 60,000 training examples and 10,000 test examples. Each example comprises a 28x28 greyscale image and an associated label

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{n+nn}{.}\PYG{n+nn}{data} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{datasets}
\PYG{k+kn}{from} \PYG{n+nn}{torchvision}\PYG{n+nn}{.}\PYG{n+nn}{transforms} \PYG{k+kn}{import} \PYG{n}{ToTensor}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{training\PYGZus{}data} \PYG{o}{=} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{FashionMNIST}\PYG{p}{(}
    \PYG{n}{root}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} where the train test data is stored}
    \PYG{n}{train}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} specifies training or testing dataset}
    \PYG{n}{download}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} specifies if its local or on internet}
    \PYG{n}{transform}\PYG{o}{=}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} specifies the type it is transformed to}
\PYG{p}{)}

\PYG{n}{test\PYGZus{}data} \PYG{o}{=} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{FashionMNIST}\PYG{p}{(}
    \PYG{n}{root}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{train}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
    \PYG{n}{download}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{transform}\PYG{o}{=}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Displaying random items from dataset}
\label{\detokenize{Week1/1PytorchTutorial:displaying-random-items-from-dataset}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{labels\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T\PYGZhy{}Shirt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Trouser}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pullover}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Dress}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{4}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Coat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{5}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sandal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{6}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Shirt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{7}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sneaker}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{8}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bag}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{l+m+mi}{9}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ankle Boot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{\PYGZsh{} Labels for each of the clothes in the dataset}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{sample\PYGZus{}idx} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{training\PYGZus{}data}\PYG{p}{)}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{img}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{n}{training\PYGZus{}data}\PYG{p}{[}\PYG{n}{sample\PYGZus{}idx}\PYG{p}{]}
        \PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{n}{labels\PYGZus{}map}\PYG{p}{[}\PYG{n}{label}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{off}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{d17471d5a2104296e05dfebdf2af24ece1aead6b72aa68bd5423403deb9eddd9}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Example: A basic machine learning algorithm with pytorch}
\label{\detokenize{Week1/1PytorchTutorial:example-a-basic-machine-learning-algorithm-with-pytorch}}
\sphinxAtStartPar
Firstly random input and output data is generated. Here \(x\) will represent the angle in radians and \(y\) will represent the sin of that angle, being predicted. \(y^-\) is the prediction of \(y\). The loss function is given as:
\$\(L = \sum^n_{i=1} (y_i^--y_i)^2\)\(
Minimizing the loss function means the predicted curve gets closer to the true curve. The loss is minimized by computing the gradient of \)L\( with respect to each parameter.
\)\(\frac{\partial L}{\partial a_{t}} = 2 \sum^n_{i=1} (y_i^- - y_i)\)\(
\)\(\frac{\partial L}{\partial b_{t}} = 2 \sum^n_{i=1} (y_i^- - y_i)x_i\)\(
\)\(\frac{\partial L}{\partial c_{t}} = 2 \sum^n_{i=1} (y_i^- - y_i)x_i^2\)\(
\)\(\frac{\partial L}{\partial d_{t}} = 2 \sum^n_{i=1} (y_i^- - y_i)x_i^3\)\(
These gradients are then used to update the parameters using gradient descent.
\)\(a_{t+1} = a_t - \eta \frac{\partial L}{\partial a_t}\)\(
\)\(b_{t+1} = b_t - \eta \frac{\partial L}{\partial b_t}\)\(
\)\(c_{t+1} = c_t - \eta \frac{\partial L}{\partial c_t}\)\(
\)\(d_{t+1} = d_t - \eta \frac{\partial L}{\partial d_t}\)\$

\sphinxAtStartPar
Where \(\eta\) is the learning rate, a hyperparameter that controls how much to change the parameters in response to the computed gradients. \sphinxstyleemphasis{\(\eta\) is initially set to be low to visualize the effects of gradient descent}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dtype} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{float}
\PYG{n}{device} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cpu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Generate random input and output data}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{2000}\PYG{p}{,} \PYG{n}{device}\PYG{o}{=}\PYG{n}{device}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtype}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Randomly initialise weights for polynomial}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{device}\PYG{o}{=}\PYG{n}{device}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtype}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{device}\PYG{o}{=}\PYG{n}{device}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtype}\PYG{p}{)}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{device}\PYG{o}{=}\PYG{n}{device}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtype}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{device}\PYG{o}{=}\PYG{n}{device}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtype}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} colours for the graph}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{learning\PYGZus{}rate} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2000}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} predict y}
    \PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{n}{x} \PYG{o}{+} \PYG{n}{c}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{d}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}
    
    \PYG{c+c1}{\PYGZsh{} compute loss}
    \PYG{n}{loss} \PYG{o}{=} \PYG{p}{(}\PYG{n}{y\PYGZus{}pred} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}
    
    \PYG{c+c1}{\PYGZsh{} compute gradients with respect to a, b, c, d}
    \PYG{n}{grad\PYGZus{}y\PYGZus{}pred} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{p}{(}\PYG{n}{y\PYGZus{}pred} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{grad\PYGZus{}a} \PYG{o}{=} \PYG{n}{grad\PYGZus{}y\PYGZus{}pred}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{grad\PYGZus{}b} \PYG{o}{=} \PYG{p}{(}\PYG{n}{grad\PYGZus{}y\PYGZus{}pred} \PYG{o}{*} \PYG{n}{x}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{grad\PYGZus{}c} \PYG{o}{=} \PYG{p}{(}\PYG{n}{grad\PYGZus{}y\PYGZus{}pred} \PYG{o}{*} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{grad\PYGZus{}d} \PYG{o}{=} \PYG{p}{(}\PYG{n}{grad\PYGZus{}y\PYGZus{}pred} \PYG{o}{*} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
    
    \PYG{c+c1}{\PYGZsh{} update weights}
    \PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{learning\PYGZus{}rate} \PYG{o}{*} \PYG{n}{grad\PYGZus{}a}
    \PYG{n}{b} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{learning\PYGZus{}rate} \PYG{o}{*} \PYG{n}{grad\PYGZus{}b}
    \PYG{n}{c} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{learning\PYGZus{}rate} \PYG{o}{*} \PYG{n}{grad\PYGZus{}c}
    \PYG{n}{d} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{learning\PYGZus{}rate} \PYG{o}{*} \PYG{n}{grad\PYGZus{}d}
    
    \PYG{k}{if} \PYG{n}{t} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{250} \PYG{o}{==} \PYG{l+m+mi}{249}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{loss}\PYG{p}{)}
        \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fitting a cubic function to sin(x)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{o}{.}\PYG{n}{detach}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y\PYGZus{}pred: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ trials}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{)}
        \PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y}\PYG{o}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y=sin(x)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
249 678.7615356445312
499 260.70501708984375
749 104.14237976074219
999 45.139129638671875
1249 22.75472640991211
1499 14.203689575195312
1749 10.913901329040527
1999 9.639151573181152
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x74267d270690\PYGZgt{}]
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{8b2653390e73eb5db134944e8c71a05f6eaca27b5ea9fb344f08981e667d86f0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Week 2 \sphinxhyphen{} Deblurring Methods}

\sphinxstepscope


\chapter{Fourier Transforms in 2D}
\label{\detokenize{Week2/12DFowierTransforms:fourier-transforms-in-2d}}\label{\detokenize{Week2/12DFowierTransforms::doc}}
\sphinxAtStartPar
Fourier Analysis offers a way to analyse images in terms of their frequency components. This is important in image processing, as it can offer a better description of an image rather than to say sharp/blury or clear/noisy. Furthermore fourier transfomrs are an important tool to understand how different filters work in the frequency domain.


\section{Aims}
\label{\detokenize{Week2/12DFowierTransforms:aims}}\begin{itemize}
\item {} 
\sphinxAtStartPar
To compute the 2D fourier transform of basic images

\item {} 
\sphinxAtStartPar
To understand how different image features (edges, lines, gradients) are represented in the frequency domain

\end{itemize}


\section{Theory}
\label{\detokenize{Week2/12DFowierTransforms:theory}}
\sphinxAtStartPar
A 2D Fourier Transform or a discrtete Fourier Transform (DFT) transforms a 2D signal (like an image) from the spartial domain to the frequency domain. The 2D Fourier transform of an image does not have a an analytic result (the result is a table of values rather than an analytic expression as in the 1D case), it however possible to visualise the results of a 2D fourier transform. The DFT is similarly to the 1D case :
\begin{equation*}
\begin{split}F(u, v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) e^{-2\pi i \left(\frac{ux}{M} + \frac{vy}{N}\right)}\end{split}
\end{equation*}
\sphinxAtStartPar
and its inverse is given by:
\begin{equation*}
\begin{split}f(x, y) = \frac{1}{MN} \sum_{u=0}^{M-1} \sum_{v=0}^{N-1} F(u, v) e^{2\pi i \left(\frac{ux}{M} + \frac{vy}{N}\right)}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(f(x,y)\) is the input image, \(F(u,v)\) is the fourier transform of the image, and \(M\) and \(N\) are the dimensions of the image. The variables \(x\) and \(y\) are the spatial coordinates, while \(u\) and \(v\) are the frequency coordinates.


\section{Load image}
\label{\detokenize{Week2/12DFowierTransforms:load-image}}
\sphinxAtStartPar
First 4 basic images were loaded and there fourier transforms were analyzed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{transforms}
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{} Load images}
\PYG{n}{folder} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Images/}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{images} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LongLine.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ShortLine.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BigSquare.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SmallSquare.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{img\PYGZus{}tensors} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{image} \PYG{o+ow}{in} \PYG{n}{images}\PYG{p}{:}
    \PYG{n}{image\PYGZus{}path} \PYG{o}{=} \PYG{n}{folder} \PYG{o}{+} \PYG{n}{image}  \PYG{c+c1}{\PYGZsh{} Replace with your image path}
    \PYG{n}{image} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{image\PYGZus{}path}\PYG{p}{)}
    \PYG{n}{transform} \PYG{o}{=} \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Compose}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Grayscale}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Convert to grayscale}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Resize to 64x64 for simplicity}
    \PYG{p}{]}\PYG{p}{)}
    \PYG{n}{img\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{transform}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Remove channel dimension if grayscale}
    \PYG{n}{img\PYGZus{}tensors}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{transforms}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3} \PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}torchvision\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Displaying Images}
\label{\detokenize{Week2/12DFowierTransforms:displaying-images}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Display the images}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sharex} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensors}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{title}\PYG{o}{.}\PYG{n}{set\PYGZus{}text}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Image }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{7a2166398e68b88469e872c753e6b4ffaa98fa0eb178403c4743f5436352de55}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Hypothesizing Fourier transform results}
\label{\detokenize{Week2/12DFowierTransforms:hypothesizing-fourier-transform-results}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Image 1:} A thin horizontal line along the entire x\sphinxhyphen{}axis is made up from a single component with a frequency of 0. Much like a 1D fourier transform the fourier transform of this should be a bright central line along the u\sphinxhyphen{}axis (the x frequency axis).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Image 2:} A thin horizontal line along part of the x\sphinxhyphen{}axis is made up from a range of low frequency components. The fourier transform of this should be a bright central line along the u\sphinxhyphen{}axis (representing the zero frequency line) but with some width to it.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Image 3:} A large square in the center of the image is made up from a range of low frequency components, due to the sharp edges of the square.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Image 4:} A small square in the center of the image is going to be made up from higher frequency components than image 3, since the square is smaller.

\end{itemize}


\section{2D DFT using PyTorch}
\label{\detokenize{Week2/12DFowierTransforms:d-dft-using-pytorch}}
\sphinxAtStartPar
By applying the fast fourier transform (FFT) function in PyTorch, the 2D DFT of the images were calculated. The FFT function in PyTourch uses the Cooley\sphinxhyphen{}Tukey algorithm which has efficency \(\mathbb{O}N\log{N}\), significantly faster than direct DFT. It is expected that the DFT of the first imageâ€¦

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{img\PYGZus{}tensor\PYGZus{}fs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{magnitude\PYGZus{}spectrum\PYGZus{}tensors} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{img\PYGZus{}tensor} \PYG{o+ow}{in} \PYG{n}{img\PYGZus{}tensors}\PYG{p}{:}
    \PYG{n}{img\PYGZus{}tensor\PYGZus{}f} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{img\PYGZus{}tensor\PYGZus{}fs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor\PYGZus{}f}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Display results}
\label{\detokenize{Week2/12DFowierTransforms:display-results}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{sharex}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{sharey}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}


\PYG{n}{ylabels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{xlabels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{freq\PYGZus{}xlabels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spatial Domain}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Frequency Domain (log scale)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Spatial domain}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensors}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{n}{ylabels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{n}{xlabels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Frequency domain}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{log1p}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor\PYGZus{}fs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{n}{freq\PYGZus{}xlabels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{5ced7db842d2cd0fd23eaba2cb7d8b42c1f4ea1e38e776343e2f909746a674e1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{img} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{)}

\PYG{n}{center} \PYG{o}{=} \PYG{l+m+mi}{256}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}
\PYG{n}{square\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{half\PYGZus{}square} \PYG{o}{=} \PYG{n}{square\PYGZus{}size} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}

\PYG{n}{img}\PYG{p}{[}\PYG{n}{center}\PYG{o}{\PYGZhy{}}\PYG{n}{half\PYGZus{}square}\PYG{p}{:}\PYG{n}{center}\PYG{o}{+}\PYG{n}{half\PYGZus{}square}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} 
    \PYG{n}{center}\PYG{o}{\PYGZhy{}}\PYG{n}{half\PYGZus{}square}\PYG{p}{:}\PYG{n}{center}\PYG{o}{+}\PYG{n}{half\PYGZus{}square}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Fourier transform of real image}
\label{\detokenize{Week2/12DFowierTransforms:fourier-transform-of-real-image}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Forier transformed pigeon}
\PYG{n}{image\PYGZus{}path} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Images/pigeon.jpeg}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{pigeon} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{image\PYGZus{}path}\PYG{p}{)}
\PYG{n}{transform} \PYG{o}{=} \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Compose}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Grayscale}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Convert to grayscale}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Resize}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} Resize to 256x256 to speed up processing}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}  
    \PYG{p}{]}\PYG{p}{)}
\PYG{n}{pigeon\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{transform}\PYG{p}{(}\PYG{n}{pigeon}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Remove channel dimension if grayscale}
\PYG{n}{box\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fft\PYGZus{}img\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{pigeon\PYGZus{}tensor}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{log1p}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{fft\PYGZus{}img\PYGZus{}tensor}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plasma}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pigeon\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{11}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5} \PYG{n}{transform} \PYG{o}{=} \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Compose}\PYG{p}{(}\PYG{p}{[}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{6}         \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Grayscale}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Convert to grayscale}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{7}         \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Resize}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} Resize to 256x256 to speed up processing}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{8}         \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}  
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{9}     \PYG{p}{]}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{10} \PYG{n}{pigeon\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{transform}\PYG{p}{(}\PYG{n}{pigeon}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Remove channel dimension if grayscale}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{11} \PYG{n}{box\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{12} \PYG{n}{fft\PYGZus{}img\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{pigeon\PYGZus{}tensor}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{14} \PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n+nn}{File \PYGZti{}/anaconda3/envs/BScProject/lib/python3.11/site\PYGZhy{}packages/torchvision/transforms/transforms.py:137,} in \PYG{n+ni}{ToTensor.\PYGZus{}\PYGZus{}call\PYGZus{}\PYGZus{}}\PYG{n+nt}{(self, pic)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{129} \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}call\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{pic}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{130}\PYG{+w}{     }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{131}\PYG{l+s+sd}{     Args:}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{132}\PYG{l+s+sd}{         pic (PIL Image or numpy.ndarray): Image to be converted to tensor.}
\PYG{l+s+sd}{   (...)    135         Tensor: Converted image.}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{136}\PYG{l+s+sd}{     \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{137}     \PYG{k}{return} \PYG{n}{F}\PYG{o}{.}\PYG{n}{to\PYGZus{}tensor}\PYG{p}{(}\PYG{n}{pic}\PYG{p}{)}

\PYG{n+nn}{File \PYGZti{}/anaconda3/envs/BScProject/lib/python3.11/site\PYGZhy{}packages/torchvision/transforms/functional.py:142,} in \PYG{n+ni}{to\PYGZus{}tensor}\PYG{n+nt}{(pic)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{140}     \PYG{n}{\PYGZus{}log\PYGZus{}api\PYGZus{}usage\PYGZus{}once}\PYG{p}{(}\PYG{n}{to\PYGZus{}tensor}\PYG{p}{)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{141} \PYG{k}{if} \PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{F\PYGZus{}pil}\PYG{o}{.}\PYG{n}{\PYGZus{}is\PYGZus{}pil\PYGZus{}image}\PYG{p}{(}\PYG{n}{pic}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{\PYGZus{}is\PYGZus{}numpy}\PYG{p}{(}\PYG{n}{pic}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{142}     \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pic should be PIL Image or ndarray. Got }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{pic}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{144} \PYG{k}{if} \PYG{n}{\PYGZus{}is\PYGZus{}numpy}\PYG{p}{(}\PYG{n}{pic}\PYG{p}{)} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{\PYGZus{}is\PYGZus{}numpy\PYGZus{}image}\PYG{p}{(}\PYG{n}{pic}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{145}     \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pic should be 2/3 dimensional. Got }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{pic}\PYG{o}{.}\PYG{n}{ndim}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ dimensions.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+ne}{TypeError}: pic should be PIL Image or ndarray. Got \PYGZlt{}class \PYGZsq{}torch.Tensor\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Results}
\label{\detokenize{Week2/12DFowierTransforms:results}}\begin{itemize}
\item {} 
\sphinxAtStartPar
For the first two images there are additional low frequency components. This is because the line is not infinitely thin, and so there are some low frequency components to represent the thickness of the line in the \(v\) direction (the \(y\) frequency axis).

\item {} 
\sphinxAtStartPar
DFTs mostly align with the predictions. Except for perhaps image 4 where there are more higher frequency components in the \(u\) direction than expected.

\end{itemize}


\section{Conclusion}
\label{\detokenize{Week2/12DFowierTransforms:conclusion}}
\sphinxstepscope


\chapter{Basics of image de\sphinxhyphen{}blurring}
\label{\detokenize{Week2/2ImageDebluring:basics-of-image-de-blurring}}\label{\detokenize{Week2/2ImageDebluring::doc}}
\sphinxAtStartPar
Blur filters are low pass filters, they remove high frequency components which are usually associated with noise. Low pass filters applied to images makes them look bury. A pixel is blurred by taking the average over the surrounding pixels. Doing this for each pixel individually is slow but can be sped up using convolution.


\section{Contents}
\label{\detokenize{Week2/2ImageDebluring:contents}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Image noise

\item {} 
\sphinxAtStartPar
How convolution can be used to speed up image filtering?

\item {} 
\sphinxAtStartPar
The process which noise and blur effect images

\item {} 
\sphinxAtStartPar
Convolution and de\sphinxhyphen{}convolution to blur and de\sphinxhyphen{}blur images

\item {} 
\sphinxAtStartPar
De\sphinxhyphen{}convolution in de\sphinxhyphen{}blur noisy images

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{transforms}
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{transforms}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3} \PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}torchvision\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Load images}
\label{\detokenize{Week2/2ImageDebluring:load-images}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load images}
\PYG{n}{folder} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Images/}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{device} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cpu}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{image} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pigeon.jpeg}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{image\PYGZus{}path} \PYG{o}{=} \PYG{n}{folder} \PYG{o}{+} \PYG{n}{image}  \PYG{c+c1}{\PYGZsh{} Replace with your image path}
\PYG{n}{image} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{image\PYGZus{}path}\PYG{p}{)}
\PYG{n}{transform} \PYG{o}{=} \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Compose}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Grayscale}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Convert to grayscale}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Resize}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} Resize to 256x256 to speed up processing}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}  
    \PYG{p}{]}\PYG{p}{)}
\PYG{n}{img\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{transform}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Remove channel dimension}

\PYG{c+c1}{\PYGZsh{} Display the image}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(np.float64(\PYGZhy{}0.5), np.float64(255.5), np.float64(255.5), np.float64(\PYGZhy{}0.5))
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{15962b066531de0ac47604357b02c2b3f8c8b5613bf736374b56b5cb1a8238da}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Shot noise (poisson noise)}
\label{\detokenize{Week2/2ImageDebluring:shot-noise-poisson-noise}}
\sphinxAtStartPar
Occurs when there is a finite number of particles that carry energy, such as photons in an image sensor or electrons in a circuit. Shot noise is one of the main types of noise that degrade image quality.

\sphinxAtStartPar
Shot noise follows a Poisson distribution because:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Discrete countable events}: Each photon arrival is a discrete, countable event

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Constant Average Rate \(\lambda\)}: The average rate of photon arrivals depends on the light intensity (brighter = more photons per second)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{No simultaneous Events}: In any tiny time interval, the probability of a photon arriving is very small. In an infinitesimally small window the probability of more than one event occuring is \(\approx 0\)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Independent}: Previous photon arrivals donâ€™t affect future arrivals

\end{enumerate}

\sphinxAtStartPar
These conditions exactly match the assumptions of a Poisson process. The number of photons detected in a fixed time period (\(\Delta t\)) follows:
\begin{equation*}
\begin{split}P(k) = \frac{\lambda^k e^{-\lambda}}{k!}\end{split}
\end{equation*}
\sphinxAtStartPar
Where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(k\) = number of photons detected

\item {} 
\sphinxAtStartPar
\(\lambda\) = average number of photons arriving in \(\Delta t\) (proportional to light intensity)

\item {} 
\sphinxAtStartPar
Higher \(\lambda\) = brighter pixel = more photons = less relative noise

\item {} 
\sphinxAtStartPar
Lower \(\lambda\) = darker pixel = fewer photons = more relative noise

\end{itemize}

\sphinxAtStartPar
This is why images taken in low light (few photons) are much noisier than images in bright light (many photons).


\section{Method}
\label{\detokenize{Week2/2ImageDebluring:method}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of photons in each pixel was simulated depending on the brightness of the pixel and its scale factor (\(s\)).

\item {} 
\sphinxAtStartPar
The photon count was set as the expected number of photons in the pixel \(sP(x)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{torch.poisson}} randomly generates the number of photons present due to random variation

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Add realistic Poisson (shot) noise to an image}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image: Input tensor in range [0,1]}
\PYG{l+s+sd}{        scale\PYGZus{}factor: Higher values = less noise (more photons)}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Convert to photon counts (scale up to simulate photon detection)}
    \PYG{n}{photon\PYGZus{}counts} \PYG{o}{=} \PYG{n}{image} \PYG{o}{*} \PYG{n}{scale\PYGZus{}factor}
    
    \PYG{c+c1}{\PYGZsh{} Apply Poisson noise }
    \PYG{n}{noisy\PYGZus{}photons} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{poisson}\PYG{p}{(}\PYG{n}{photon\PYGZus{}counts}\PYG{p}{)}
    
    \PYG{c+c1}{\PYGZsh{} Convert back to [0,1] range}
    \PYG{n}{noisy\PYGZus{}image} \PYG{o}{=} \PYG{n}{noisy\PYGZus{}photons} \PYG{o}{/} \PYG{n}{scale\PYGZus{}factor}
    
    \PYG{k}{return} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{clamp}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}image}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create noisy images with different noise levels}
\PYG{n}{torch}\PYG{o}{.}\PYG{n}{manual\PYGZus{}seed}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}  

\PYG{c+c1}{\PYGZsh{} Low noise (high photon count)}
\PYG{n}{noisy\PYGZus{}low} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{5000}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Medium noise }
\PYG{n}{noisy\PYGZus{}medium} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} High noise (low photon count \PYGZhy{} like low light)}
\PYG{n}{noisy\PYGZus{}high} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Display results}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Original Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}low}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scale factor = 5000}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}medium}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scale factor = 500}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}high}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scale factor = 50}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{584f7b9b4cace48341e5dbbbbaeab4ece4bbddbfb02d6976069add1870f227e7}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Results}
\label{\detokenize{Week2/2ImageDebluring:results}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The smaller the scale factor (number of photons) the noisier the image, which in reality is what happens.

\item {} 
\sphinxAtStartPar
A key property of a poisson distribution is that the mean and variance are both \(\lambda\). Increasing \(s\) increases \(\lambda\) and therefore should increase the absolute noise. The relative noise decreases, this is clear from looking at the signal to noise ratio \(R\)
\$\(R = \frac{\text{noise}}{\text{signal}} = \frac{\sqrt{\lambda}}{\lambda} = \frac{1}{\sqrt{\lambda}}\)\$

\item {} 
\sphinxAtStartPar
This explains why higher photon counts produce clearer images.

\end{itemize}


\section{Filtering in 2D}
\label{\detokenize{Week2/2ImageDebluring:filtering-in-2d}}
\sphinxAtStartPar
Filtering in 2D works by acting a discrete function q (dimensions \(X\), \(M\)) on an underlying image p:
\$\(p'(x,y) = \sum_{n=-X}^{X} \sum_{m=-Y}^{Y} p(x+n,y+m) \cdot q(n,m)\)\$


\section{Filtering Example: The box filter}
\label{\detokenize{Week2/2ImageDebluring:filtering-example-the-box-filter}}
\sphinxAtStartPar
The box filter is a type of low pass filter which helps to remove noise and blurs images. It works by setting the pixel value \(p_{x,y}\) to be the average of the \(N\) pixels above it and \(M\) pixels below it.
\begin{equation*}
\begin{split}\tag{1} p'(x,y) = \frac{1}{(2N+1)(2M+1)} \sum_{n=-N}^{N} \sum_{m=-M}^{M} p(x+n,y+m)\end{split}
\end{equation*}
\sphinxAtStartPar
This algorithm is incredibly slow when implemented with nested loops since computing each pixel value has an efficiency of \(\mathbb{O}(N^2)\) which for the overall image will have efficiency \(\mathbb{O}(N^4)\), since each pixel needs to be filtered in the \(x\) and \(y\) direction. This can be rapidly increased using convolution.


\section{Convolution}
\label{\detokenize{Week2/2ImageDebluring:convolution}}
\sphinxAtStartPar
The convolution of two functions is given by the multiplication of the fourier transforms. The convolution theorem states that the convolution of two functions \(v(x)\) and \(u(x)\) can be given in terms of their fourier transforms \(V(k)\) and \(U(k)\) respectively:
\begin{equation*}
\begin{split}f(x) = v(x) * u(x) = \mathcal{F}^{-1}\{V(k) \cdot U(k)\} \tag{2}\end{split}
\end{equation*}
\sphinxAtStartPar
Where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(*\) denotes convolution

\item {} 
\sphinxAtStartPar
\(\mathcal{F}^{-1}\) is the inverse Fourier transform

\item {} 
\sphinxAtStartPar
\(\cdot\) denotes pointwise multiplication
Convolution in spatial domain is the same as multiplication in frequency domain. The convolution method can greatly improve the efficiency of applying filters especially when using the fast fourier transform. The nested loop approach has efficiency \(\mathbb{O}(N^4)\) (\(\mathbb{O}(N^2)\) per pixel) where as transfering to the frequency domain increases the efficency to \(\mathbb{O}(N^2) \log(N)\) (\(\mathbb{O}(\log{N})\) per pixel). Furthermore there are advantages to using the better optimized pytorch tensors compared to using inefficient python loops.
Convolution corresponds to numerically represents multiplication of every value in the list \(v(x)\) with every value in the list \(u(x)\).

\end{itemize}


\subsection{The box filter}
\label{\detokenize{Week2/2ImageDebluring:the-box-filter}}
\sphinxAtStartPar
The box function is the â€œconvolution kernelâ€ for this type of filter, which describes which surrounding pixel values will be used to form the filtered pixel value \(p'_{x,y}\). It is described as:
\begin{equation*}
\begin{split}\text{box}_{N,M}(n,m) = \begin{cases} 
\frac{1}{(2N+1)(2M+1)} & \text{if} -N \leq n \leq N \text{ and} - M \leq m \leq M \\
0 & \text{else}
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
e.g.
\begin{equation*}
\begin{split}\text{box}_{2,2}(n,m) = \end{split}
\end{equation*}
\sphinxAtStartPar
To blur the image the the box function is applied to the image using convolution.
\begin{equation*}
\begin{split}p'(x,y) = p(x,y) * \text{box}_{N,M}(x,y)\end{split}
\end{equation*}
\sphinxAtStartPar
or generally
\$\(p'(x,y) = p(x,y) * q(x,y)\)\$


\subsubsection{Creating box functions}
\label{\detokenize{Week2/2ImageDebluring:creating-box-functions}}
\sphinxAtStartPar
Different shapes of box functions were created and there bluing effects were analyzed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{box\PYGZus{}function}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{kernel} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{N} \PYG{o}{*} \PYG{n}{M}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{kernel}

\PYG{n}{val} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{square\PYGZus{}kernel} \PYG{o}{=} \PYG{n}{box\PYGZus{}function}\PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}
\PYG{n}{horizontal\PYGZus{}kernel} \PYG{o}{=} \PYG{n}{box\PYGZus{}function}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}
\PYG{n}{vertical\PYGZus{}kernel} \PYG{o}{=} \PYG{n}{box\PYGZus{}function}\PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsubsection{Carry out convolution}
\label{\detokenize{Week2/2ImageDebluring:carry-out-convolution}}\begin{equation*}
\begin{split}p'(x,y) = p(x,y) * \text{box}_{N,M}(x,y)\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{nn}\PYG{n+nn}{.}\PYG{n+nn}{functional} \PYG{k}{as} \PYG{n+nn}{F}

\PYG{k}{def} \PYG{n+nf}{convolution}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zeros}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}    
    \PYG{c+c1}{\PYGZsh{} Apply convolution with padding to maintain image size}
    \PYG{n}{padding} \PYG{o}{=} \PYG{p}{(}\PYG{n}{kernel}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{kernel}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zeros}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
        \PYG{n}{filtered} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{conv2d}\PYG{p}{(}\PYG{n}{image}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding}\PYG{o}{=}\PYG{n}{padding}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{circular}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}padded} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{cat}\PYG{p}{(}\PYG{p}{[}\PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,} \PYG{n}{image}\PYG{p}{,} \PYG{n}{image}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}padded} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{cat}\PYG{p}{(}\PYG{p}{[}\PYG{n}{image\PYGZus{}padded}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}\PYG{p}{,} \PYG{n}{image\PYGZus{}padded}\PYG{p}{,} \PYG{n}{image\PYGZus{}padded}\PYG{p}{[}\PYG{p}{:}\PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{filtered} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{conv2d}\PYG{p}{(}\PYG{n}{image\PYGZus{}padded}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reflect}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}padded} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{pad}\PYG{p}{(}\PYG{n}{image}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reflect}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{filtered} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{conv2d}\PYG{p}{(}\PYG{n}{image\PYGZus{}padded}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}padded} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{pad}\PYG{p}{(}\PYG{n}{image}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{padding}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{filtered} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{conv2d}\PYG{p}{(}\PYG{n}{image\PYGZus{}padded}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{==} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{filtered} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{conv2d}\PYG{p}{(}\PYG{n}{image}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}   
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Unsupported padding mode: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{padding\PYGZus{}mode}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    
    \PYG{c+c1}{\PYGZsh{} Remove batch and channel dimensions: [1, 1, H, W] \PYGZhy{}\PYGZgt{} [H, W]}
    \PYG{k}{return} \PYG{n}{filtered}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Original}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{kernel} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{p}{[}\PYG{n}{square\PYGZus{}kernel}\PYG{p}{,} \PYG{n}{horizontal\PYGZus{}kernel}\PYG{p}{,} \PYG{n}{vertical\PYGZus{}kernel}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{filtered\PYGZus{}img} \PYG{o}{=} \PYG{n}{convolution}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{filtered\PYGZus{}img}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{titles} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{, M = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N = 1, M = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{, M = 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{n}{titles}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{012aa73f5246571fb7d0c830093a0f28da83155bb6f18c37803f3f26f1641357}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Discussion}
\label{\detokenize{Week2/2ImageDebluring:discussion}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The results show that the square box filter causes equal bluing in both directions.

\item {} 
\sphinxAtStartPar
The horizontal box filter causes bluing in only the horizontal direction.

\item {} 
\sphinxAtStartPar
Similarly for the vertical box filter.

\end{itemize}


\section{De\sphinxhyphen{}convolution}
\label{\detokenize{Week2/2ImageDebluring:de-convolution}}
\sphinxAtStartPar
The images can be de\sphinxhyphen{}blurred via de\sphinxhyphen{}convolution using the convolution kernel. De convolution is working out \(v(x)\) knowing \(f(x)\) and \(u(x)\) given \(f(x) = v(x) * u(x)\) . The inverse (de\sphinxhyphen{}convolution) is:
\$\(v(x) = \mathcal{F}^{-1}\left\{\frac{F(k)}{H(k)}\right\} \tag{3}\)\(
Since the convolution kernel for the blured images is known the original image can be recovered.
\)\(p(x,y) = \mathcal{F}^{-1}\left\{\frac{P'(u,v)}{B(u,v)}\right\} \tag{4}\)\$

\sphinxAtStartPar
Where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(B(k) = \mathcal{F}\{h(x)\}\) is the Fourier transform of the blur kernel in this case the fourier transform of the box function

\item {} 
\sphinxAtStartPar
\(P'(u,v) = \mathcal{F}\{p'(x,y)\}\) is the Fourier transform of the blurred image

\end{itemize}


\section{Convolving and then de\sphinxhyphen{}convolving the image}
\label{\detokenize{Week2/2ImageDebluring:convolving-and-then-de-convolving-the-image}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The image is first blurred using convolution with the box function

\item {} 
\sphinxAtStartPar
The blurred image is then de\sphinxhyphen{}blurred using de\sphinxhyphen{}convolution with the box function

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{deconvolution}\PYG{p}{(}\PYG{n}{blurred\PYGZus{}image}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{epsilon}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Compute Fourier transforms}
    \PYG{n}{P\PYGZus{}blurred} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{blurred\PYGZus{}image}\PYG{p}{)}
    \PYG{n}{B} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{kernel}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{blurred\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
    
    \PYG{c+c1}{\PYGZsh{} Avoid division by zero by adding a small constant (epsilon)}
    \PYG{n}{B\PYGZus{}conj} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}
    \PYG{n}{B\PYGZus{}magnitude\PYGZus{}squared} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{n}{B\PYGZus{}inv} \PYG{o}{=} \PYG{n}{B\PYGZus{}conj} \PYG{o}{/} \PYG{p}{(}\PYG{n}{B\PYGZus{}magnitude\PYGZus{}squared} \PYG{o}{+} \PYG{n}{epsilon}\PYG{p}{)}
    
    \PYG{c+c1}{\PYGZsh{} Perform deconvolution in the frequency domain}
    \PYG{n}{P\PYGZus{}deblurred} \PYG{o}{=} \PYG{n}{P\PYGZus{}blurred} \PYG{o}{*} \PYG{n}{B\PYGZus{}inv}

    \PYG{c+c1}{\PYGZsh{} Inverse Fourier transform to get the deblurred image}
    \PYG{n}{deblurred\PYGZus{}image} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{ifft2}\PYG{p}{(}\PYG{n}{P\PYGZus{}deblurred}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}
    
    \PYG{k}{return} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{clamp}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}image}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{square\PYGZus{}kernel} \PYG{o}{=} \PYG{n}{box\PYGZus{}function}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{square\PYGZus{}blured} \PYG{o}{=} \PYG{n}{convolution}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{square\PYGZus{}kernel}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{deblurred\PYGZus{}img} \PYG{o}{=} \PYG{n}{deconvolution}\PYG{p}{(}\PYG{n}{square\PYGZus{}blured}\PYG{p}{,} \PYG{n}{square\PYGZus{}kernel}\PYG{p}{,} \PYG{n}{epsilon}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Original Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{square\PYGZus{}blured}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Blurred Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}img}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Deblurred Image (Square Kernel)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{62a71f982ffc23afd31a93a4be43ca25813666e28e80105e7d2e451939f5adf0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Discussion}
\label{\detokenize{Week2/2ImageDebluring:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The deconvolution process is not perfect. Artifacts are introduced in the image, especially around the edges potentially due to boundary effects and noise amplification.

\item {} 
\sphinxAtStartPar
Furthermore, the box filter is not a perfect low\sphinxhyphen{}pass filter. While it should attenuate higher frequencies, this doesnâ€™t always work due to its frequency response characteristics.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Counter\sphinxhyphen{}example}: A high frequency alternating signal \(p(x) = [..., 1, -1, 1, -1, 1, ...]\) convolved with a 1Ã—1 box filter:
\$\(p'(x) = p(x) * \text{box}_1(x)\)\$
The high frequency signal passes through unchanged.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Example of lower frequency attenuation}: A lower frequency signal \(p(x) = [..., 1, -0.5, -0.5, 1, -0.5, -0.5, ...]\) when convolved with \(\text{box}_1\) gives \(\mathbb{0}\), showing selective frequency attenuation.

\item {} 
\sphinxAtStartPar
Box filters give each pixel within the â€œboxâ€ equal weighting. In reality pixels closer to the middle will have larger weighting

\item {} 
\sphinxAtStartPar
Convolving a box filter on a box filter does not give a box filter. This is a problem since applying a box filter twice isnâ€™t doubling the amount of â€œblurâ€.

\item {} 
\sphinxAtStartPar
Division by small values in \(H(k)\) can amplify noise and introduce artifacts. Especially as the box filter may attenuate certain frequencies to near zero.

\end{itemize}


\section{Padding}
\label{\detokenize{Week2/2ImageDebluring:padding}}
\sphinxAtStartPar
Padding is likely the cause of some of the artifacts seen in the de\sphinxhyphen{}blurred images. When convolving near the edges of an image, there are not enough surrounding pixels to apply the filter properly. Padding adds extra pixels around the border of the image to mitigate this issue. In this case


\section{Gaussian filters}
\label{\detokenize{Week2/2ImageDebluring:gaussian-filters}}
\sphinxAtStartPar
The gaussian filter is defined in 1 dimension as:
\$\(g_{\sigma}(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}\)\(
or in 2 dimensions as:
\)\(g_{\sigma}(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}}\)\(
Where \)\textbackslash{}sigma\( is the standard deviation which controls the width of the gaussian. The larger the \)\textbackslash{}sigma\$ the wider the gaussian and therefore the more blurring that occurs. The gaussian filter is a better low\sphinxhyphen{}pass filter than the box filter since it gives more weighting to pixels closer to the center.


\section{Image Degrading}
\label{\detokenize{Week2/2ImageDebluring:image-degrading}}
\sphinxAtStartPar
images become degraded by convolving the image with a guassian kernel then adding noise.
\$\(d(x,y) = p(x,y) * q(x,y) + n(x,y)\)\(
then an attempt to recover the original image was made using
\)\(p(x,y) = d(x,y) / q(x,y) = \mathcal{F}^{-1}\left\{\frac{D(x,y)}{Q(x,y)}\right\} \tag{4}\)\$

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gaussian\PYGZus{}normalised\PYGZus{}kernel}\PYG{p}{(}\PYG{n}{size}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Generate a 2D Gaussian kernel.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{size} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{size} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{p}{)}
    \PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{,} \PYG{n}{ax}\PYG{p}{,} \PYG{n}{indexing}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ij}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{kernel} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{xx}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{yy}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{kernel} \PYG{o}{=} \PYG{n}{kernel} \PYG{o}{/} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{kernel}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{kernel}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Shape: [1, 1, size, size]}

\PYG{n}{gaussian\PYGZus{}kernel1} \PYG{o}{=} \PYG{n}{gaussian\PYGZus{}normalised\PYGZus{}kernel}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{sigma}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}
\PYG{n}{gaussian\PYGZus{}blured1} \PYG{o}{=} \PYG{n}{convolution}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{gaussian\PYGZus{}kernel1}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{replicate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{degraded\PYGZus{}gaussian\PYGZus{}blured1} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{gaussian\PYGZus{}blured1}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}
\PYG{n}{deblurred\PYGZus{}gaussian1} \PYG{o}{=} \PYG{n}{deconvolution}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}gaussian\PYGZus{}blured1}\PYG{p}{,} \PYG{n}{gaussian\PYGZus{}kernel1}\PYG{p}{,} \PYG{n}{epsilon}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)}

\PYG{n}{gaussian\PYGZus{}kernel2} \PYG{o}{=} \PYG{n}{gaussian\PYGZus{}normalised\PYGZus{}kernel}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{sigma}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{n}{gaussian\PYGZus{}blured2} \PYG{o}{=} \PYG{n}{convolution}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{gaussian\PYGZus{}kernel2}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{replicate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{degraded\PYGZus{}gaussian\PYGZus{}blured2} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{gaussian\PYGZus{}blured2}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}
\PYG{n}{deblurred\PYGZus{}gaussian2} \PYG{o}{=} \PYG{n}{deconvolution}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}gaussian\PYGZus{}blured2}\PYG{p}{,} \PYG{n}{gaussian\PYGZus{}kernel2}\PYG{p}{,} \PYG{n}{epsilon}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Original Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}gaussian\PYGZus{}blured1}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Blurred Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}gaussian1}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Deblurred Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Original Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}gaussian\PYGZus{}blured2}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Blurred Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}gaussian2}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Deblurred Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{42f0c3857743b1b5ee99c5e53ea5ffead93716690211bb43140877e383c90bb0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{gaussian\PYGZus{}kernel1}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(np.float64(\PYGZhy{}0.5), np.float64(9.5), np.float64(9.5), np.float64(\PYGZhy{}0.5))
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{159f781e695d6db70ac573d3fb4c65a8b9ef91628eb61577521646322b82ae17}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Discussion}
\label{\detokenize{Week2/2ImageDebluring:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The de\sphinxhyphen{}bluring from the gaussian filters is significantly better than the box filter, especially for the heavily blured image.

\item {} 
\sphinxAtStartPar
There are some edge artifacts present in the de\sphinxhyphen{}blured images, but not as bad as the box filter.

\item {} 
\sphinxAtStartPar
This seems to be related to kernel size since larger kernels produce more edge artifacts

\item {} 
\sphinxAtStartPar
This could be because the code assumes that the image is infinately periodic.

\end{itemize}


\section{Realistic noise}
\label{\detokenize{Week2/2ImageDebluring:realistic-noise}}
\sphinxAtStartPar
Realistically noise and blur occur together. This time an image will be blured using the gaussian filter and then poisson noise will be added, to simulate realistic image acquisition conditions. The image will then be de\sphinxhyphen{}blured, using the convolution kernel.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Using your existing variables}

\PYG{n}{gaussian\PYGZus{}kernel3} \PYG{o}{=} \PYG{n}{gaussian\PYGZus{}normalised\PYGZus{}kernel}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{sigma}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{no\PYGZus{}blur\PYGZus{}kernel} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{tensor}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Identity kernel for no blur}

\PYG{n}{blur\PYGZus{}levels} \PYG{o}{=}  \PYG{p}{[}\PYG{p}{(}\PYG{n}{no\PYGZus{}blur\PYGZus{}kernel}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{No Blur}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
                \PYG{p}{(}\PYG{n}{gaussian\PYGZus{}kernel2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Light Blur (Ïƒ=1.0)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} 
                \PYG{p}{(}\PYG{n}{gaussian\PYGZus{}kernel1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Heavy Blur (Ïƒ=2.0)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{noise\PYGZus{}levels} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{50000000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{No Noise}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Medium Noise}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{High Noise}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{axes} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{noise\PYGZus{}levels}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{blur\PYGZus{}levels}\PYG{p}{)}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{n}{noise\PYGZus{}scale}\PYG{p}{,} \PYG{n}{noise\PYGZus{}label}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{noise\PYGZus{}levels}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j}\PYG{p}{,} \PYG{p}{(}\PYG{n}{kernel}\PYG{p}{,} \PYG{n}{blur\PYGZus{}label}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{blur\PYGZus{}levels}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Blur then add noise}
        \PYG{n}{blurred} \PYG{o}{=} \PYG{n}{convolution}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{noisy\PYGZus{}blurred} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{blurred}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{n}{noise\PYGZus{}scale}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{kernel}\PYG{o}{.}\PYG{n}{equal}\PYG{p}{(}\PYG{n}{no\PYGZus{}blur\PYGZus{}kernel}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{deblured} \PYG{o}{=} \PYG{n}{noisy\PYGZus{}blurred} 
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{deblured} \PYG{o}{=} \PYG{n}{deconvolution}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}blurred}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{epsilon}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)}
        \PYG{n}{axes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{deblured}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{axes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{axes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
        
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:}
            \PYG{n}{axes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{n}{blur\PYGZus{}label}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n}{fontweight}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bold}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{j} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{axes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{n}{noise\PYGZus{}label}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n}{fontweight}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bold}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.02}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Increasing Blur â†’}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ha}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n}{fontweight}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bold}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.02}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{â† Increasing Noise}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{va}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rotation}\PYG{o}{=}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n}{fontweight}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bold}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots\PYGZus{}adjust}\PYG{p}{(}\PYG{n}{bottom}\PYG{o}{=}\PYG{l+m+mf}{0.08}\PYG{p}{,} \PYG{n}{left}\PYG{o}{=}\PYG{l+m+mf}{0.08}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{deblurring\PYGZus{}results.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{8b20100a8796c8ef88a4a363dd0e2d78740191e3e21c796e812c131573e7bff3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Discussion}
\label{\detokenize{Week2/2ImageDebluring:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Blur on its own can be successfully removed using de convolution.

\item {} 
\sphinxAtStartPar
However when noise is added the de convolution process generates artifacts which makes it even more difficult to recover the original image.

\item {} 
\sphinxAtStartPar
After noise present after the de convolution process is no longer random but seems to have more structure than the original noise since there are more distinct patches of black and white.

\item {} 
\sphinxAtStartPar
This noise due to noise and blur is more visually disturbing than noise or blur.

\end{itemize}


\section{Summary}
\label{\detokenize{Week2/2ImageDebluring:summary}}
\sphinxAtStartPar
De convolution was used to de blur images which had been convolved with a known kernel. This worked very well for images which had been blurred but not corrupted with noise. But realistically acquired images will be blurred and will have noise on top of this. De convoluting the noisy images did not work well and created artifacts in the image, which was visually more disturbing than gaussian noise.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{noisy\PYGZus{}img\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}
\PYG{n}{blurred\PYGZus{}noisy\PYGZus{}img} \PYG{o}{=} \PYG{n}{convolution}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{box\PYGZus{}function}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{blurred\PYGZus{}noisy\PYGZus{}img}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{noisy\PYGZus{}blurred\PYGZus{}image.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2c105a411c7069a6a6a7ce445386da213d75a72b0e817cc850490eeb1014fb43}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Week 3 and 4 \sphinxhyphen{} Richardson and Lucy Algorithm}

\sphinxstepscope


\chapter{Richardson Lucy Algorithm}
\label{\detokenize{Week3/1richardsonlucy:richardson-lucy-algorithm}}\label{\detokenize{Week3/1richardsonlucy::doc}}
\sphinxAtStartPar
Even knowing convolution kernel isnâ€™t enough to de\sphinxhyphen{}blur an image. This is because any noise present in the image is amplified during de\sphinxhyphen{}convolution and adds significant visual disturbances. This section looks at the Richardson Lucy algorithm which is an iterative method for recovering convoluted images which are also corrupted by noise.


\section{Aims}
\label{\detokenize{Week3/1richardsonlucy:aims}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Understand the Richardson Lucy algorithm

\item {} 
\sphinxAtStartPar
Implement the Richardson Lucy algorithm and deblur images

\item {} 
\sphinxAtStartPar
Compare the Richardson Lucy algorithm with just using the Fourier transform to deconvolve a noisy image.

\end{itemize}


\section{Theory}
\label{\detokenize{Week3/1richardsonlucy:theory}}
\sphinxAtStartPar
The matrices \(f\), \(f'\) and \(k\) describe the proportion of light in: the true image, the observed image and the convolution kernel respectively, and are related by either \(f'_i =\sum_j k_{i,j}f_j\) or \(f' = f * k\). When the letters are unscripted (e.g. \(f\)) that means they are referring to the whole array. When they are scripted (e.g. \(f_{i}\)) then they are referring to the value in the \(i\) th location.

\sphinxAtStartPar
The Richardson Lucy algorithm is an iterative process which predicts predicts the true image accounting for noise:
\$\(\hat{f}_j^{t+1} = \hat{f}_j^{t}\sum_i \frac{f'^{t}_i}{\hat{f'}^{t}_i}k_{i,j} \text{  [1]}\)\$
\begin{itemize}
\item {} 
\sphinxAtStartPar
Where \(\hat{f}_j^{t+1}\) is the \(t+1\) th estimated value of \(f_j\).

\item {} 
\sphinxAtStartPar
\(\hat{f'}_i\) is the predicted light intensity in the observed image given as \(\hat{f'}_i = \sum_j k_{i,j}\hat{f}_j\).

\item {} 
\sphinxAtStartPar
\(\frac{f'^t_i}{\hat{f}^{t}_i}\) is the correcting factor. It determines the difference between the measured light intensity and the prediction of the light intensity from the previous estimate.

\item {} 
\sphinxAtStartPar
If \(p_{i,j}\) is normalized (\(\sum_j p_{i,j} = 1\))

\item {} 
\sphinxAtStartPar
The richardson lucy algorithm often converges as the process is self correcting {[}1{]}.

\end{itemize}

\sphinxAtStartPar
Using convolution the algorithm can be written for the 2D case:
\$\(\hat{p}^{t+1} = \hat{p}^{t} \cdot \left(\frac{d^t}{\hat{d}^{t}}*q^* \right)\)\$
\begin{itemize}
\item {} 
\sphinxAtStartPar
Where \(\hat{p}^{t}\) is the \(t\) th estimated value of \(p\).

\item {} 
\sphinxAtStartPar
Where \(q^*\) is the mirrored convolution kernel.

\item {} 
\sphinxAtStartPar
\(\hat{d}\) is the predicted light intensity in the observed image given as: \(\hat{d}^{t} = \hat{p}^{t} * q\).

\item {} 
\sphinxAtStartPar
\(\frac{d^t_i}{\hat{d}^{t}_i}\) is the correcting factor.

\end{itemize}


\section{Basic 1D implementat}
\label{\detokenize{Week3/1richardsonlucy:basic-1d-implementat}}

\section{Python implementation}
\label{\detokenize{Week3/1richardsonlucy:python-implementation}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{transforms}
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{ImageDebluring} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{transforms}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3} \PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}torchvision\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Degrading the image}
\label{\detokenize{Week3/1richardsonlucy:degrading-the-image}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load images}
\PYG{n}{folder} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Images/}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{device} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cpu}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{image} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pigeon.jpeg}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{image\PYGZus{}path} \PYG{o}{=} \PYG{n}{folder} \PYG{o}{+} \PYG{n}{image}  \PYG{c+c1}{\PYGZsh{} Replace with your image path}
\PYG{n}{image} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{image\PYGZus{}path}\PYG{p}{)}
\PYG{n}{transform} \PYG{o}{=} \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Compose}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Grayscale}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Convert to grayscale}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Resize}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} Resize to 256x256 to speed up processing}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}  
    \PYG{p}{]}\PYG{p}{)}
\PYG{n}{img\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{transform}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Remove channel dimension}

\PYG{c+c1}{\PYGZsh{} Display the image}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(np.float64(\PYGZhy{}0.5), np.float64(255.5), np.float64(255.5), np.float64(\PYGZhy{}0.5))
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{15962b066531de0ac47604357b02c2b3f8c8b5613bf736374b56b5cb1a8238da}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{signal} \PYG{k+kn}{import} \PYG{n}{convolve2d} \PYG{k}{as} \PYG{n}{conv2}

\PYG{k+kn}{from} \PYG{n+nn}{skimage} \PYG{k+kn}{import} \PYG{n}{color}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{restoration}


\PYG{n}{iters\PYGZus{}rl} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{kernel} \PYG{o}{=} \PYG{n}{gaussian\PYGZus{}normalised\PYGZus{}kernel}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{n}{sigma}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}
\PYG{n}{blury\PYGZus{}image} \PYG{o}{=} \PYG{n}{convolution}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{)}
\PYG{n}{degraded\PYGZus{}image} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{blury\PYGZus{}image}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}

\PYG{n}{restored\PYGZus{}image\PYGZus{}ft} \PYG{o}{=} \PYG{n}{deconvolution}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}image}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{)}
\PYG{n}{restored\PYGZus{}image\PYGZus{}rl30} \PYG{o}{=} \PYG{n}{richardson\PYGZus{}lucy}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}image}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{num\PYGZus{}iters}\PYG{o}{=}\PYG{n}{iters\PYGZus{}rl}\PYG{p}{)}
\PYG{n}{restored\PYGZus{}image\PYGZus{}rlski} \PYG{o}{=} \PYG{n}{restoration}\PYG{o}{.}\PYG{n}{richardson\PYGZus{}lucy}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}image}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{kernel}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{num\PYGZus{}iter}\PYG{o}{=}\PYG{n}{iters\PYGZus{}rl}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Display the results}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{img\PYGZus{}tensor}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Original Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}image}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Degraded Image}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{restored\PYGZus{}image\PYGZus{}ft}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Restored Image (Fourier Deconvolution)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{restored\PYGZus{}image\PYGZus{}rl30}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Restored Image (Richardson\PYGZhy{}Lucy, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iters\PYGZus{}rl}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ iters)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
kernel shape: torch.Size([11, 11])
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{3106d14c753c93a8f8f44b98c9dc6a06a81d2985b492c2ba35d37310611993cf}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Discussion}
\label{\detokenize{Week3/1richardsonlucy:discussion}}\begin{itemize}
\item {} 
\sphinxAtStartPar
De\sphinxhyphen{}convolution by fourier transform doesnâ€™t work. The image is unrecognisable and the noise seems to have been amplified by the de\sphinxhyphen{}convolution.

\item {} 
\sphinxAtStartPar
The Richardson Lucy algorithm removes most of the noise and also helps to de\sphinxhyphen{}blur the image. The contrast on the new image isnâ€™t as clear as the original image but is much better than the observed image.

\item {} 
\sphinxAtStartPar
The skimage implementation of the RLA has the same effect as the one programmed above with no noticeable difference for 5 iterations. However for a larger number of iterations the above implementation causes the image to become very dark. Prehaps this is due to the normalisation factor \(\frac{f'^t_i}{\hat{f}^{t}_i}\) always being less than 1. It is unclear why this is happening.

\item {} 
\sphinxAtStartPar
Although the RLA seems to work for the complex image (pigeon) the darkening after a larger number of iterations is concerning. Each time the convolution kernel is applied over the image it makes the image smaller, therefore padding is used to keep the image the same size. The padding involves adding zeros to the edge of the image where the convolution cannot be applied. This means that the edge of the image is darker than the rest of the image. The RLA is an iterative process and therefore this darkening effect is amplified each time the convolution kernel is applied, therefore the image becomes darker after many iterations especially when the kernel size and standard deviation are large.

\end{itemize}

\sphinxstepscope


\chapter{Tuning the Richardson\sphinxhyphen{}Lucy Algorithm with 1D functions}
\label{\detokenize{Week3/2richardsonlucy:tuning-the-richardson-lucy-algorithm-with-1d-functions}}\label{\detokenize{Week3/2richardsonlucy::doc}}
\sphinxAtStartPar
Its faster and simpler to experiment with 1D functions than 2D images. The same algorithm is used in 1D as it is in 2D. Furthermore there is more 1D data than 2D data.


\chapter{Aims}
\label{\detokenize{Week3/2richardsonlucy:aims}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Understand how random noise is changed by convolution

\item {} 
\sphinxAtStartPar
Test the Richardson\sphinxhyphen{}Lucy Algorithm (RLA) in 1D

\item {} 
\sphinxAtStartPar
Tune the RLA parameters in order to maximize PSNR (peak signal to noise ratio) and SSIM (structural similarity index measure).

\end{itemize}


\section{Deconvolving a 1D signal}
\label{\detokenize{Week3/2richardsonlucy:deconvolving-a-1d-signal}}
\sphinxAtStartPar
A square wave was convolved using a gaussian kernel and then poisson noise was added. The square wave was normalized between \(0\) and \(1\) as this was the 2D signal (image) was prepared as the same algorithms were used. The RLA was then used to try and recover the original signal.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{ImageDebluring} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}
\PYG{k+kn}{from} \PYG{n+nn}{torchvision} \PYG{k+kn}{import} \PYG{n}{transforms}


\PYG{k}{def} \PYG{n+nf}{step\PYGZus{}function}\PYG{p}{(}\PYG{n}{period}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{xs} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{steps}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}
    \PYG{n}{ys} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{xs}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n}{period}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{float}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{k}{return} \PYG{n}{xs}\PYG{p}{,} \PYG{n}{ys}

\PYG{k}{def} \PYG{n+nf}{sin\PYGZus{}function}\PYG{p}{(}\PYG{n}{period}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{xs} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{steps}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}
    \PYG{n}{ys} \PYG{o}{=} \PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{xs} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{n}{period}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}
    \PYG{k}{return} \PYG{n}{xs}\PYG{p}{,} \PYG{n}{ys}

\PYG{k}{def} \PYG{n+nf}{pigeon\PYGZus{}function}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{image} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Images/pigeon.jpeg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{convert}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Convert to grayscale}
    \PYG{n}{transform} \PYG{o}{=} \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Compose}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{Resize}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Resize to 1x1000}
        \PYG{n}{transforms}\PYG{o}{.}\PYG{n}{ToTensor}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{]}\PYG{p}{)}
    \PYG{n}{img\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{transform}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Remove channel dimension}
    \PYG{k}{return} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{steps}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{,} \PYG{n}{img\PYGZus{}tensor}


\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}deblurring\PYGZus{}example}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{num\PYGZus{}iters} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor} \PYG{o}{=} \PYG{l+m+mi}{5000}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{title} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{title} \PYG{o}{=} \PYG{n}{func}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{signal} \PYG{o}{=} \PYG{n}{y}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add batch and channel dimensions}
    \PYG{n}{kernel} \PYG{o}{=} \PYG{n}{gaussian\PYGZus{}normalised\PYGZus{}kernel\PYGZus{}1D}\PYG{p}{(}\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{p}{)}

    \PYG{n}{blurred\PYGZus{}signal} \PYG{o}{=} \PYG{n}{convolution\PYGZus{}1D}\PYG{p}{(}\PYG{n}{signal}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{n}{padding\PYGZus{}mode}\PYG{p}{)}
    \PYG{n}{measured\PYGZus{}signal} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{blurred\PYGZus{}signal}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{n}{scale\PYGZus{}factor}\PYG{p}{)}

    \PYG{n}{deblurred\PYGZus{}signal} \PYG{o}{=} \PYG{n}{richardson\PYGZus{}lucy}\PYG{p}{(}\PYG{n}{measured\PYGZus{}signal}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{num\PYGZus{}iters}\PYG{o}{=}\PYG{n}{num\PYGZus{}iters}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{n}{padding\PYGZus{}mode}\PYG{p}{)}

    \PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{fig}\PYG{o}{.}\PYG{n}{suptitle}\PYG{p}{(}\PYG{n}{title}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Step Function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{measured\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Measured Signal (Blurred + Noisy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{blurred\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Blurred Signal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Estimated Signal (Richardson\PYGZhy{}Lucy, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{num\PYGZus{}iters}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ iters)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3} \PYG{k+kn}{from} \PYG{n+nn}{ImageDebluring} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}torch\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Padding}
\label{\detokenize{Week3/2richardsonlucy:padding}}
\sphinxAtStartPar
After a convolution the size of the image decreases since the kernel cannot be applied around edge pixels. For a kernel of size \(n\) and an image of size \(m\) the convoluted image will have size \(m-n+1\). This is problematic since the LRA requires the measured image and the kernel to be the same size. Padding increases the size of the image by adding pixels around the edge.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zeros padding: the easiest to implement form of padding. The edge pixels are set to zero. The problem with zeros padding is that overtime it will decrease the overall brightness of the image starting from the edges. This means that a more iterations will gradually decrease the brightness of the image.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot\PYGZus{}deblurring\PYGZus{}example}\PYG{p}{(}\PYG{n}{pigeon\PYGZus{}function}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zeros}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Zeros Padding}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{num\PYGZus{}iters} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{f682e7c774a672e5104de5920d433e1c90133dd6a77b437a11840d27101c3224}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The measured signal is far from the true signal since the edge pixels are much darker due to the zeros padding. Here there are also erroneous results since some pixel intensities are greater than 1.
\begin{itemize}
\item {} 
\sphinxAtStartPar
replicate padding repeats the value of the edge pixels. This means that the overall image is not darkened like when using zeros padding.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot\PYGZus{}deblurring\PYGZus{}example}\PYG{p}{(}\PYG{n}{pigeon\PYGZus{}function}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Replicate Padding}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{num\PYGZus{}iters} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{040571555b77b263325d200b73ee59db367ddec467a0c80b4ff037f4ee96c655}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The replicate padding works much more successfully as there isnâ€™t issues around edge pixels. The image will not lose brightness over time.


\section{Measures of image quality}
\label{\detokenize{Week3/2richardsonlucy:measures-of-image-quality}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\(R^2\) measures the correlation between the estimated signal and the true signal. However this has low human visual relevance. A higher \(R^2\) indicates that the overall shape of the estimated signal is a close match to the true signal.

\item {} 
\sphinxAtStartPar
MSE measures the average squared difference between the estimated signal and the true signal. Again this has low human visual relevance. This doesnâ€™t capture perceptual image quality well. A lower MSE indicates a higher quality image.

\item {} 
\sphinxAtStartPar
The PSNR is the logarithmic ratio between signal power to error power and is given in db since its logarithmic. This has a higher visual relevance compared to MSE. A value between 30 and 50 db indicates that the image is a good quality. Below 25db indicates heavy distortion or noise.

\item {} 
\sphinxAtStartPar
The SSIM compares the luminance, contrast and structure of the estimated signal to the true signal. This has a high visual relevance. A SSIM of 1 indicates a perfect match to the true signal a SSIM of above 0.97 indicates a good match a SSIM of below 0.95 indicates significant degregation.

\end{itemize}


\section{Number of iterations}
\label{\detokenize{Week3/2richardsonlucy:number-of-iterations}}
\sphinxAtStartPar
Its also easier to find training datasets for machine learning algorithms in 1D. The Richardson lucy algorithm has 3 â€œtuning parametersâ€ the first is the convolution kernel which is assumed to be a gaussian with known standard deviation. The second is the number of iterations the algorithm runs for. The third is the initial guess. The following graphs show how the number of iterations of the RLA effects how close the estimated signal is to the true signal. The results from this section will be used to help train a machine learning algorithm to predict the optimal number of iterations for a given image.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torchmetrics}
\PYG{k+kn}{from} \PYG{n+nn}{skimage} \PYG{k+kn}{import} \PYG{n}{metrics}

\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}iterations\PYGZus{}example}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor} \PYG{o}{=} \PYG{l+m+mi}{5000}
                            \PYG{p}{,} \PYG{n}{iters} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,} \PYG{n}{plot\PYGZus{}all} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{fig} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{n}{signal} \PYG{o}{=} \PYG{n}{y}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}  
    \PYG{n}{kernel} \PYG{o}{=} \PYG{n}{gaussian\PYGZus{}normalised\PYGZus{}kernel\PYGZus{}1D}\PYG{p}{(}\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{p}{)}
    \PYG{n}{blurred\PYGZus{}signal} \PYG{o}{=} \PYG{n}{convolution\PYGZus{}1D}\PYG{p}{(}\PYG{n}{signal}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{n}{padding\PYGZus{}mode}\PYG{p}{)}
    \PYG{n}{measured\PYGZus{}signal} \PYG{o}{=} \PYG{n}{add\PYGZus{}poisson\PYGZus{}noise}\PYG{p}{(}\PYG{n}{blurred\PYGZus{}signal}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor}\PYG{o}{=}\PYG{n}{scale\PYGZus{}factor}\PYG{p}{)}
    \PYG{n}{r2s} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{mses}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
    \PYG{n}{PSNRs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{SSIMs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    
    \PYG{k}{if} \PYG{n}{plot\PYGZus{}all}\PYG{p}{:}
        \PYG{n}{fig1}\PYG{p}{,} \PYG{n}{axs1} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sharex}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{sharey}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{n}{axs1} \PYG{o}{=} \PYG{n}{axs1}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}
        
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{iters}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{deblurred\PYGZus{}signal} \PYG{o}{=} \PYG{n}{richardson\PYGZus{}lucy}\PYG{p}{(}\PYG{n}{measured\PYGZus{}signal}\PYG{p}{,} \PYG{n}{kernel}\PYG{p}{,} \PYG{n}{num\PYGZus{}iters}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{n}{padding\PYGZus{}mode}\PYG{p}{)}
        \PYG{n}{r2} \PYG{o}{=} \PYG{n}{torchmetrics}\PYG{o}{.}\PYG{n}{functional}\PYG{o}{.}\PYG{n}{r2\PYGZus{}score}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{mse} \PYG{o}{=} \PYG{n}{torchmetrics}\PYG{o}{.}\PYG{n}{functional}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{r2s}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{r2}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{mses}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{mse}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{PSNR} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{mse}\PYG{p}{)}
        \PYG{n}{SSIM} \PYG{o}{=} \PYG{n}{metrics}\PYG{o}{.}\PYG{n}{structural\PYGZus{}similarity}\PYG{p}{(}\PYG{n}{y}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{deblurred\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{data\PYGZus{}range}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}
        \PYG{n}{PSNRs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{PSNR}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{SSIMs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{SSIM}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{o}{/}\PYG{n}{iters}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        
        \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{iters} \PYG{o+ow}{and} \PYG{n}{plot\PYGZus{}all}\PYG{p}{:}
            \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{measured\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dashed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
            \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{y}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dotted}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
            \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{}axs1[j].legend([\PYGZsq{}Estimated Signal\PYGZsq{}, \PYGZsq{}Measured Signal\PYGZsq{}, \PYGZsq{}True Signal\PYGZsq{}], framealpha=1.0)}
            \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Richardson\PYGZhy{}Lucy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ iters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RÂ² = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{r2}\PYG{l+s+si}{:}\PYG{l+s+s1}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{transform}\PYG{o}{=}\PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{transAxes}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{verticalalignment}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bottom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{horizontalalignment}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{left}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{j} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        
        
    \PYG{k}{if} \PYG{n}{fig} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{axs} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{PSNRs}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{n}{label}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Iterations}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PSNR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{SSIMs}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{n}{label}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Iterations}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SSIM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    
    \PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot\PYGZus{}iterations\PYGZus{}example}\PYG{p}{(}\PYG{n}{step\PYGZus{}function}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Replicate Padding}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor} \PYG{o}{=} \PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{iters} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{,} \PYG{n}{period} \PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
25.0 \PYGZpc{}999999999998 \PYGZpc{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{IndexError}\PYG{g+gWhitespace}{                                }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{plot\PYGZus{}iterations\PYGZus{}example}\PYG{p}{(}\PYG{n}{step\PYGZus{}function}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Replicate Padding}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor} \PYG{o}{=} \PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{iters} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{,} \PYG{n}{period} \PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{p}{)}

\PYG{n+nn}{Cell In[4], line 34,} in \PYG{n+ni}{plot\PYGZus{}iterations\PYGZus{}example}\PYG{n+nt}{(func, padding\PYGZus{}mode, title, scale\PYGZus{}factor, iters, plot\PYGZus{}all, fig, axs, label, **kwargs)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{31} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{o}{/}\PYG{n}{iters}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{33} \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{iters} \PYG{o+ow}{and} \PYG{n}{plot\PYGZus{}all}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{34}     \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{deblurred\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{35}     \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{measured\PYGZus{}signal}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dashed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{36}     \PYG{n}{axs1}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{y}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dotted}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}

\PYG{n+ne}{IndexError}: index 6 is out of bounds for axis 0 with size 6
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{a2b70d72b7a2ea37a26bb6baa525ec3565f83256cecacab90fcf780476dbfb93}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When the number of iterations are low the estimated signal is smooth and this doesnâ€™t reflect the shape of the true signal, especially around the vertical lines. As the number of iterations increases the shape of the estimated signal improves. The steepness of the lines from where the square wave changes value value increases. However as the number of iterations increases the noise from the estimated signal also increases. Often the signal will become noisy even when there is no noise in the measured signal.

\sphinxAtStartPar
It is clear from both the graph of \(R^2\) score against iteration and the graph of MSE against iteration that the RLA is converging towards a solution. This solution doesnâ€™t appear to be the optimal solution since after 200 iterations the \(R^2\) value hadnâ€™t yet hit \(0.95\). Similarly the MSE seems to be converging to a value at about \(0.003\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot\PYGZus{}iterations\PYGZus{}example}\PYG{p}{(}\PYG{n}{sin\PYGZus{}function}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Replicate Padding}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor} \PYG{o}{=} \PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{iters} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
100.0 \PYGZpc{}9999999999 \PYGZpc{}\PYGZpc{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZlt{}Figure size 1200x500 with 2 Axes\PYGZgt{},
 array([\PYGZlt{}Axes: xlabel=\PYGZsq{}Iterations\PYGZsq{}, ylabel=\PYGZsq{}PSNR\PYGZsq{}\PYGZgt{},
        \PYGZlt{}Axes: xlabel=\PYGZsq{}Iterations\PYGZsq{}, ylabel=\PYGZsq{}SSIM\PYGZsq{}\PYGZgt{}], dtype=object))
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{6db4bdb04d9021f7ceabe2dd3de51ef764e5806281255bbe6d275d4b6706dad2}.png}

\noindent\sphinxincludegraphics{{1f7fad8baf6e2ced99b2050eb1af764642a65d54dca0c8fc7ecb11fed3d37e15}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In this example the convolution doesnâ€™t make so much difference to the true signal as its smoother. This means that there is less to be gained by carrying out more iterations of the RLA since the shape of the signal is already satisfactory. Carrying out more iterations just adds noise to the signal although this seems relativly insignificant as seen from the very large \(R^2\) value of \(0.998\).

\sphinxAtStartPar
Here the RLA initially gets very close to the true signal but then starts to diverge after 10 iterations. The reasons for this are unclear but may be to do with specific frequencies which the RLA is amplifying. By extending the graph it is clear that it doesnâ€™t seem to a solution after 1000 iterations, perhaps the rate of convergence is very slow.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot\PYGZus{}iterations\PYGZus{}example}\PYG{p}{(}\PYG{n}{pigeon\PYGZus{}function}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Replicate Padding}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scale\PYGZus{}factor} \PYG{o}{=} \PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{iters} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
100.0 \PYGZpc{}9999999999 \PYGZpc{}\PYGZpc{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZlt{}Figure size 1200x500 with 2 Axes\PYGZgt{},
 array([\PYGZlt{}Axes: xlabel=\PYGZsq{}Iterations\PYGZsq{}, ylabel=\PYGZsq{}PSNR\PYGZsq{}\PYGZgt{},
        \PYGZlt{}Axes: xlabel=\PYGZsq{}Iterations\PYGZsq{}, ylabel=\PYGZsq{}SSIM\PYGZsq{}\PYGZgt{}], dtype=object))
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{ab11251717e1b743d799d9468b97ddfd6187a313473ffdc0b8f9d0fd965165f4}.png}

\noindent\sphinxincludegraphics{{ea7c37fa294ecd32d26a0cb84588f82e8ffc3a39f2c4f4c6c180654a57e20026}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
After about 4 iterations the RLA has got as close as it gets to the true signal with a \(R^2\) of about 0.993. After this the RLA diverges away from the true signal as the estimated signal becomes very noisy. The divergence in this case is much worse than in the previous example. This suggests that the number of iterations is an important variable to tune using machine learning.


\section{Conclusion}
\label{\detokenize{Week3/2richardsonlucy:conclusion}}
\sphinxAtStartPar
Padding is necessary to keep the signal size the same after convolution which is essential in the RLA. Replicate padding doesnâ€™t cause the images to darken over time and prevents artifacts being introduced into the solution due to boundary effects.

\sphinxAtStartPar
The number of iterations effects how close the estimated signal can get to the true signal. Selecting a number of iterations is a tradeoff between how well the shape of the estimated signal matches the true signal and how noisy the estimated signal is. The optimal number of iterations seems to be lower for real world signals perhaps due to the different frequency components of the signal.

\sphinxstepscope


\part{Week 5\sphinxhyphen{}8 \sphinxhyphen{} Neural Networks}

\sphinxstepscope


\chapter{Neural Networks for Image De\sphinxhyphen{}noising}
\label{\detokenize{Week7/MachineLearningFunction:neural-networks-for-image-de-noising}}\label{\detokenize{Week7/MachineLearningFunction::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Understand how multi\sphinxhyphen{}layer neural networks function.

\item {} 
\sphinxAtStartPar
Build a multi layer perceptron that can analyze and deconvolve step functions

\end{itemize}


\section{Theory}
\label{\detokenize{Week7/MachineLearningFunction:theory}}
\sphinxAtStartPar
Assume the noisy image can be written as a matrix \(P_{i}\) where each element represents the pixel intensity of the \(i\) th pixel. The goal is to train a neural network \(f(P; K)\) where \(K\) is the known convolution kernel to output a denoised image \(Q_{i} = f(P; K)\). The nodes between the inputs and the outputs are the â€˜hidden nodesâ€™. All nodes have a value between 0 and 1.

\sphinxAtStartPar
\sphinxincludegraphics{{Week7/attachment:image}.png}

\sphinxAtStartPar
The node \(a^{(1)}_0\) will have its value computed from a sum of the weighted inputs from the first layer.
\begin{equation*}
\begin{split}a^{(1)}_0 = \sigma(b_0+\sum_{i} w_{i}P_{i})\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\sigma\) is the normalisation function given by \(\sigma(x) = \frac{1}{1 + e^{-x}}\). \(w_{i}\) are the weights associated with each input pixel \(P_{i}\), \(b_0\) is the bias term.

\sphinxAtStartPar
The first next layer of hidden nodes can be calculated from:
\begin{equation*}
\begin{split}\mathbf{a}^{(i+1)} = \sigma(W^{(i)}\mathbf{a}^{(i)} + \mathbf{b}^{(i)})\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(W^{(i)}\) is the weight matrix and \(\mathbf{b}^{(i)}\) is the bias vector which transforms the \(i\) th layer into the \(i+1\) th layer. The values of \(W^{(i)}\) and \(\mathbf{b}^{(i)}\) are learned during training.


\section{Gradient Descent}
\label{\detokenize{Week7/MachineLearningFunction:gradient-descent}}
\sphinxAtStartPar
The cost function measures the success of the machine learning algorithm one way it could be defined is as follows:
\begin{equation*}
\begin{split}C(\mathbf{w}) = \sum_i (\hat{p}_i - p_i)^2\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\hat{p}_i\) is the estimated state from the MLP and \(p_i\) is the known state. The vector \(\mathbf{w}\) contains all the weights in the network. This sum is small when the network is close to being â€œcorrectâ€.

\sphinxAtStartPar
Using gradient decent can be used to find a local minima, an optimized solution. The vector \(-\Delta C(\mathbf{w})\) points in the direction of steepest decent.


\section{Generate test data}
\label{\detokenize{Week7/MachineLearningFunction:generate-test-data}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{ImageDebluring} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{preprocessing} \PYG{k+kn}{import} \PYG{n}{MinMaxScaler}

\PYG{k}{def} \PYG{n+nf}{step\PYGZus{}function}\PYG{p}{(}\PYG{n}{period}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{amplitude}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{n}{y\PYGZus{}intercept}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{steps}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{x\PYGZus{}offset}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{steps}
    \PYG{n}{xs} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{steps}\PYG{o}{=}\PYG{n}{s}\PYG{p}{)}
    \PYG{n}{ys} \PYG{o}{=} \PYG{n}{amplitude} \PYG{o}{*} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{heaviside}\PYG{p}{(}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{xs} \PYG{o}{+} \PYG{n}{x\PYGZus{}offset}\PYG{p}{)} \PYG{o}{/} \PYG{n}{period}\PYG{p}{)}\PYG{p}{,} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{xs}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{y\PYGZus{}intercept}
    \PYG{k}{return} \PYG{n}{ys}

\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}random\PYGZus{}function}\PYG{p}{(}\PYG{n}{vary\PYGZus{}period} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}amplitude} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{rng} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{vary\PYGZus{}period}\PYG{p}{:}
        \PYG{n}{period} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{generator}\PYG{o}{=}\PYG{n}{rng}\PYG{p}{)}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{5}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{period} \PYG{o}{=} \PYG{l+m+mi}{5}
    \PYG{k}{if} \PYG{n}{vary\PYGZus{}amplitude}\PYG{p}{:}
        \PYG{n}{amplitude} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{generator}\PYG{o}{=}\PYG{n}{rng}\PYG{p}{)}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{0.9} \PYG{o}{+} \PYG{l+m+mf}{0.1}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{amplitude} \PYG{o}{=} \PYG{l+m+mf}{0.3}
    \PYG{k}{if} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept}\PYG{p}{:}
        \PYG{n}{y\PYGZus{}intercept} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{generator}\PYG{o}{=}\PYG{n}{rng}\PYG{p}{)}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{0.3}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{y\PYGZus{}intercept} \PYG{o}{=} \PYG{l+m+mf}{0.3}
    \PYG{k}{if} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset}\PYG{p}{:}
        \PYG{n}{x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{generator}\PYG{o}{=}\PYG{n}{rng}\PYG{p}{)}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{pi}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{x\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mf}{0.0}
    \PYG{k}{return} \PYG{n}{step\PYGZus{}function}\PYG{p}{(}\PYG{n}{period}\PYG{p}{,} \PYG{n}{amplitude}\PYG{p}{,} \PYG{n}{y\PYGZus{}intercept}\PYG{p}{,} \PYG{n}{x\PYGZus{}offset}\PYG{o}{=}\PYG{n}{x\PYGZus{}offset}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{unsqueeze}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}test\PYGZus{}data}\PYG{p}{(}\PYG{n}{amount} \PYG{o}{=} \PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{noise\PYGZus{}scale} \PYG{o}{=} \PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{blur\PYGZus{}std} \PYG{o}{=} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{n}{kernel\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{vary\PYGZus{}period} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}amplitude} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{rng} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{seed} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{rng} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{and} \PYG{n}{seed} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{rng} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{Generator}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{manual\PYGZus{}seed}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}
    \PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{y\PYGZus{}scalers} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{X} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{X\PYGZus{}scalers} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n}{amount}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{data} \PYG{o}{=} \PYG{n}{generate\PYGZus{}random\PYGZus{}function}\PYG{p}{(}\PYG{n}{vary\PYGZus{}period} \PYG{o}{=} \PYG{n}{vary\PYGZus{}period}\PYG{p}{,} \PYG{n}{vary\PYGZus{}amplitude} \PYG{o}{=} \PYG{n}{vary\PYGZus{}amplitude}\PYG{p}{,} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept} \PYG{o}{=} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept}\PYG{p}{,} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{rng} \PYG{o}{=} \PYG{n}{rng}\PYG{p}{)}
        \PYG{n}{degraded\PYGZus{}data} \PYG{o}{=} \PYG{n}{degrade\PYGZus{}image\PYGZus{}1D}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{noise\PYGZus{}scale}\PYG{o}{=}\PYG{n}{noise\PYGZus{}scale}\PYG{p}{,} \PYG{n}{kernel}\PYG{o}{=}\PYG{n}{gaussian\PYGZus{}normalised\PYGZus{}kernel\PYGZus{}1D}\PYG{p}{(}\PYG{n}{blur\PYGZus{}std}\PYG{p}{,} \PYG{n}{kernel\PYGZus{}size}\PYG{p}{)}\PYG{p}{,} \PYG{n}{padding\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{replicate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{scaler\PYGZus{}x} \PYG{o}{=} \PYG{n}{MinMaxScaler}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{scaler\PYGZus{}y} \PYG{o}{=} \PYG{n}{MinMaxScaler}\PYG{p}{(}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} reshape to 2D (n\PYGZus{}samples, n\PYGZus{}features) for sklearn, then back to 1D}
        \PYG{n}{degraded\PYGZus{}np} \PYG{o}{=} \PYG{n}{degraded\PYGZus{}data}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{data\PYGZus{}np} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{degraded\PYGZus{}scaled} \PYG{o}{=} \PYG{n}{scaler\PYGZus{}x}\PYG{o}{.}\PYG{n}{fit\PYGZus{}transform}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}np}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{data\PYGZus{}scaled} \PYG{o}{=} \PYG{n}{scaler\PYGZus{}y}\PYG{o}{.}\PYG{n}{fit\PYGZus{}transform}\PYG{p}{(}\PYG{n}{data\PYGZus{}np}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{degraded\PYGZus{}data} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{tensor}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)}
        \PYG{n}{data} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{tensor}\PYG{p}{(}\PYG{n}{data\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)}
        \PYG{n}{X\PYGZus{}scalers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{scaler\PYGZus{}x}\PYG{p}{)}
        \PYG{n}{y\PYGZus{}scalers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{scaler\PYGZus{}y}\PYG{p}{)}
        \PYG{n}{X}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{degraded\PYGZus{}data}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{y}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        
    \PYG{c+c1}{\PYGZsh{} Make tensors}
    \PYG{n}{X} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{stack}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{stack}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{X\PYGZus{}scalers}\PYG{p}{,} \PYG{n}{y\PYGZus{}scalers}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ModuleNotFoundError}\PYG{g+gWhitespace}{                       }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k+kn}{import} \PYG{n+nn}{torch}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3} \PYG{k+kn}{from} \PYG{n+nn}{ImageDebluring} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n+ne}{ModuleNotFoundError}: No module named \PYGZsq{}torch\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Defining the MLP model}
\label{\detokenize{Week7/MachineLearningFunction:defining-the-mlp-model}}\begin{itemize}
\item {} 
\sphinxAtStartPar
input size for this dataset is 1000 (number of points in the 1D signal)

\item {} 
\sphinxAtStartPar
hidden size can be adjusted, start with 128

\item {} 
\sphinxAtStartPar
output size is also 1000 (number of points in the 1D signal)

\item {} 
\sphinxAtStartPar
requires\_grad=True to enable backpropagation

\end{itemize}


\section{Forward Pass}
\label{\detokenize{Week7/MachineLearningFunction:forward-pass}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Linear transformation of inputs \(z^{(1)} = XW^{(1)} + b^{(1)}\)

\item {} 
\sphinxAtStartPar
Apply activation function \(a^{(1)} = \sigma(z^{(1)})\) to node values

\item {} 
\sphinxAtStartPar
Linear transformation of hidden layer \(z^{(2)} = a^{(1)}W^{(2)} + b^{(2)}\)

\item {} 
\sphinxAtStartPar
Apply activation function \(a^{(2)} = \sigma(z^{(2)})\) to get final output

\end{itemize}


\section{Backpropagation}
\label{\detokenize{Week7/MachineLearningFunction:backpropagation}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{backward}} updates the weights and the baises

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{epochs}} the number of times the model sees the entire dataset

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lr}} hyperparameter that controls the step size for weighted updates

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{loss}} the MSE

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MLP}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{input\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{output\PYGZus{}size}\PYG{p}{,} \PYG{n}{rng} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rng} \PYG{o}{=} \PYG{n}{rng}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{W1} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{input\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{generator}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rng}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{b1} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{generator}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rng}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{W2} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{output\PYGZus{}size}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{generator}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rng}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{b2} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{output\PYGZus{}size}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{generator}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rng}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{z1} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{matmul}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{W1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{b1}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{a1} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{sigmoid}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{z1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} applies sigmoid activation function}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{z2} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{matmul}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{a1}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{W2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{b2}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{a2} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{sigmoid}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{z2}\PYG{p}{)} 
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{a2}
    
    \PYG{k}{def} \PYG{n+nf}{backward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{X}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{output}\PYG{p}{,}\PYG{n}{lr}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{X}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{dz2} \PYG{o}{=} \PYG{n}{output} \PYG{o}{\PYGZhy{}} \PYG{n}{y}
        \PYG{n}{dW2} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{matmul}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{a1}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,} \PYG{n}{dz2}\PYG{p}{)}
        \PYG{n}{db2} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{dz2}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{/}\PYG{n}{m}
        
        \PYG{n}{da1} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{matmul}\PYG{p}{(}\PYG{n}{dz2}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{W2}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}
        \PYG{n}{dz1} \PYG{o}{=} \PYG{n}{da1}\PYG{o}{*}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{a1}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{dW1}\PYG{o}{=}\PYG{n}{torch}\PYG{o}{.}\PYG{n}{matmul}\PYG{p}{(}\PYG{n}{X}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,}\PYG{n}{dz1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{m}
        \PYG{n}{db1} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{dz1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{/} \PYG{n}{m}
        
        \PYG{k}{with} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{no\PYGZus{}grad}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{W1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{lr} \PYG{o}{*} \PYG{n}{dW1}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{b1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{lr} \PYG{o}{*} \PYG{n}{db1}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{W2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{lr} \PYG{o}{*} \PYG{n}{dW2}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{b2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{lr} \PYG{o}{*} \PYG{n}{db2}
            
    \PYG{k}{def} \PYG{n+nf}{train}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{epochs} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{lr} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{losses} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{losses}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{epochs}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{output} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} Compute loss using MSE}
            \PYG{n}{loss} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{(}\PYG{n}{output} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{n}{losses}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{loss}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} Update weights}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{output}\PYG{p}{,} \PYG{n}{lr}\PYG{p}{)}
            
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{Epoch }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{, Loss: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{loss}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{losses}
        
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Initialize model}
\label{\detokenize{Week7/MachineLearningFunction:initialize-model}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}losses}\PYG{p}{(}\PYG{n}{losses}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{losses}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{losses}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{train\PYGZus{}model}\PYG{p}{(}\PYG{n}{X\PYGZus{}train\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{y\PYGZus{}train\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{128}\PYG{p}{,} \PYG{n}{epochs} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{lr} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{n}{rng} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{input\PYGZus{}size} \PYG{o}{=} \PYG{n}{X\PYGZus{}train\PYGZus{}scaled}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{model} \PYG{o}{=} \PYG{n}{MLP}\PYG{p}{(}\PYG{n}{input\PYGZus{}size}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{input\PYGZus{}size}\PYG{p}{,} \PYG{n}{rng} \PYG{o}{=} \PYG{n}{rng}\PYG{p}{)}
    \PYG{n}{losses} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{n}{X\PYGZus{}train\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{y\PYGZus{}train\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{epochs}\PYG{o}{=}\PYG{n}{epochs}\PYG{p}{,} \PYG{n}{lr}\PYG{o}{=}\PYG{n}{lr}\PYG{p}{)}
    \PYG{n}{plot\PYGZus{}losses}\PYG{p}{(}\PYG{n}{losses}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{model}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Testing}
\label{\detokenize{Week7/MachineLearningFunction:testing}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{amount}} is the number of waves that are generated for training and testing

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{noise\_scale}} is the scale factor for the signal before poisson noise is added

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{blur\_std}} is the standard devation of the guassian being convolved with the signal

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kernel\_size}} is the size of the guassian being convolved with teh signal

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{epochs}} is the number of iterations that the machine learning algorithm will train for

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lr}} is the hyperparameter that controls the step size for weighted updates

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hidden\_size}} the number of hidden nodes in the MLP

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vary\_period/amplitude/y\_intercept/x\_offset}} boolean describes if these should be variables when generating the waves.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{X/y}} an optional parameter which if not provided the programme will generate its own data

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{X/y\sphinxhyphen{}scalers}} scalers so data can be unscaled after running through the machine learning algorithm

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{seaborn} \PYG{k}{as} \PYG{n+nn}{sns}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{model\PYGZus{}selection} \PYG{k+kn}{import} \PYG{n}{train\PYGZus{}test\PYGZus{}split}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}model}\PYG{p}{(}\PYG{n}{amount} \PYG{o}{=} \PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{noise\PYGZus{}scale} \PYG{o}{=} \PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{blur\PYGZus{}std} \PYG{o}{=} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{n}{kernel\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{epochs}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{lr}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{128}\PYG{p}{,} \PYG{n}{vary\PYGZus{}period}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}amplitude}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{X} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{seed\PYGZus{}data} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{seed\PYGZus{}model} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{X\PYGZus{}scalers} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{y\PYGZus{}scalers} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{X} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None} \PYG{o+ow}{and} \PYG{n}{y} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{X\PYGZus{}scaled} \PYG{o}{=} \PYG{n}{X}
        \PYG{n}{y\PYGZus{}scaled} \PYG{o}{=} \PYG{n}{y}
    \PYG{n}{rng\PYGZus{}data} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{Generator}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{manual\PYGZus{}seed}\PYG{p}{(}\PYG{n}{seed\PYGZus{}data}\PYG{p}{)}
    \PYG{n}{rng\PYGZus{}model} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{Generator}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{manual\PYGZus{}seed}\PYG{p}{(}\PYG{n}{seed\PYGZus{}model}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{X} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{y} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Generating data...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{n}{X\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{y\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{X\PYGZus{}scalers}\PYG{p}{,} \PYG{n}{y\PYGZus{}scalers} \PYG{o}{=} \PYG{n}{generate\PYGZus{}test\PYGZus{}data}\PYG{p}{(}\PYG{n}{amount} \PYG{o}{=} \PYG{n}{amount}\PYG{p}{,} \PYG{n}{noise\PYGZus{}scale} \PYG{o}{=} \PYG{n}{noise\PYGZus{}scale}\PYG{p}{,} \PYG{n}{blur\PYGZus{}std} \PYG{o}{=} \PYG{n}{blur\PYGZus{}std}\PYG{p}{,} \PYG{n}{kernel\PYGZus{}size}\PYG{o}{=}\PYG{n}{kernel\PYGZus{}size}\PYG{p}{,} \PYG{n}{vary\PYGZus{}period} \PYG{o}{=} \PYG{n}{vary\PYGZus{}period}\PYG{p}{,} \PYG{n}{vary\PYGZus{}amplitude} \PYG{o}{=} \PYG{n}{vary\PYGZus{}amplitude}\PYG{p}{,} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept} \PYG{o}{=} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept}\PYG{p}{,} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset} \PYG{o}{=} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset}\PYG{p}{,} \PYG{n}{rng} \PYG{o}{=} \PYG{n}{rng\PYGZus{}data}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Data generated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{X\PYGZus{}train\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{X\PYGZus{}test\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{y\PYGZus{}train\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{y\PYGZus{}test\PYGZus{}scaled} \PYG{o}{=} \PYG{n}{train\PYGZus{}test\PYGZus{}split}\PYG{p}{(}\PYG{n}{X\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{y\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{test\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{42}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Data preppared}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{model} \PYG{o}{=} \PYG{n}{train\PYGZus{}model}\PYG{p}{(}\PYG{n}{X\PYGZus{}train\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{y\PYGZus{}train\PYGZus{}scaled}\PYG{p}{,} \PYG{n}{epochs} \PYG{o}{=} \PYG{n}{epochs}\PYG{p}{,} \PYG{n}{lr} \PYG{o}{=} \PYG{n}{lr}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size} \PYG{o}{=} \PYG{n}{hidden\PYGZus{}size}\PYG{p}{,} \PYG{n}{rng} \PYG{o}{=} \PYG{n}{rng\PYGZus{}model}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Model trained}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{y\PYGZus{}pred\PYGZus{}scaled} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n}{X\PYGZus{}test\PYGZus{}scaled}\PYG{p}{)}
    
    \PYG{c+c1}{\PYGZsh{} Select 4 waves to vosialise}
    \PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sharex} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{sharey}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{axs} \PYG{o}{=} \PYG{n}{axs}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{n}{y\PYGZus{}scalers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{inverse\PYGZus{}transform}\PYG{p}{(}\PYG{n}{y\PYGZus{}pred\PYGZus{}scaled}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{detach}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{X\PYGZus{}test} \PYG{o}{=} \PYG{n}{X\PYGZus{}scalers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{inverse\PYGZus{}transform}\PYG{p}{(}\PYG{n}{X\PYGZus{}test\PYGZus{}scaled}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{detach}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{y\PYGZus{}test} \PYG{o}{=} \PYG{n}{y\PYGZus{}scalers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{inverse\PYGZus{}transform}\PYG{p}{(}\PYG{n}{y\PYGZus{}test\PYGZus{}scaled}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{detach}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{sns}\PYG{o}{.}\PYG{n}{lineplot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y\PYGZus{}pred}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{y\PYGZus{}pred}\PYG{p}{,} \PYG{n}{ax}\PYG{o}{=}\PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{predicted}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{)}
        \PYG{n}{sns}\PYG{o}{.}\PYG{n}{lineplot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{X\PYGZus{}test}\PYG{p}{,} \PYG{n}{ax}\PYG{o}{=}\PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{degraded}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{)}
        \PYG{n}{sns}\PYG{o}{.}\PYG{n}{lineplot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{ax}\PYG{o}{=}\PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{original}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{)}
        \PYG{n}{axs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Done!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Simplest model}
\label{\detokenize{Week7/MachineLearningFunction:simplest-model}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Simple model where the parameters defining the square wave are the same for each iteration

\item {} 
\sphinxAtStartPar
the only thing that changes is the noise that is added to the square waves each time

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test\PYGZus{}model}\PYG{p}{(}\PYG{n}{epochs}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Generating data...
Data generated
Data preppared
losses
Epoch 9, Loss: 3.0431750869253094e\PYGZhy{}11
Model trained
Done!
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{74d369c28700ffc220f4041df41234ad9824e11207168d9158ca672fa3c0c129}.png}

\noindent\sphinxincludegraphics{{ebfed17451ea45ca0a4cdf463c02bb7b707854a044b4e9411f8b7b8e6147f953}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
Converges very quickly

\item {} 
\sphinxAtStartPar
the predicted waves are identical to the square waves

\end{itemize}


\section{Varying the x offset}
\label{\detokenize{Week7/MachineLearningFunction:varying-the-x-offset}}\begin{itemize}
\item {} 
\sphinxAtStartPar
now also varying the x offset which is generated randomly

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{X\PYGZus{}scalers}\PYG{p}{,} \PYG{n}{y\PYGZus{}scalers} \PYG{o}{=} \PYG{n}{generate\PYGZus{}test\PYGZus{}data}\PYG{p}{(}\PYG{n}{amount} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{noise\PYGZus{}scale} \PYG{o}{=} \PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{n}{blur\PYGZus{}std} \PYG{o}{=} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{n}{kernel\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{test\PYGZus{}model}\PYG{p}{(}\PYG{n}{X} \PYG{o}{=} \PYG{n}{X}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{y}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{n}{epochs} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{lr} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{n}{seed\PYGZus{}data}\PYG{o}{=}\PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{seed\PYGZus{}model}\PYG{o}{=}\PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{X\PYGZus{}scalers} \PYG{o}{=} \PYG{n}{X\PYGZus{}scalers}\PYG{p}{,} \PYG{n}{y\PYGZus{}scalers} \PYG{o}{=} \PYG{n}{y\PYGZus{}scalers}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Data preppared
losses
Epoch 29, Loss: 0.32221731543540955
Model trained
Done!
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{e1abf5acb61ace925b932b9929d7997bbcfa76a81e9bdcb7c6ea8ddd3bbe3b4f}.png}

\noindent\sphinxincludegraphics{{c580de8f5889a73d00ea71b87dcae8bdc0a2cb30d08a190ef5181695f12dac6d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
This example doesnâ€™t work

\item {} 
\sphinxAtStartPar
loss vs epoch is noisy

\item {} 
\sphinxAtStartPar
considered decreasing \sphinxcode{\sphinxupquote{lr}}

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test\PYGZus{}model}\PYG{p}{(}\PYG{n}{X} \PYG{o}{=} \PYG{n}{X}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{y}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{n}{epochs} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{lr} \PYG{o}{=} \PYG{l+m+mf}{0.005}\PYG{p}{,} \PYG{n}{X\PYGZus{}scalers} \PYG{o}{=} \PYG{n}{X\PYGZus{}scalers}\PYG{p}{,} \PYG{n}{y\PYGZus{}scalers} \PYG{o}{=} \PYG{n}{y\PYGZus{}scalers}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Data preppared
losses
Epoch 49, Loss: 0.0021088530775159597
Model trained
Done!
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{db98dc1d01269d903950c424f69d1166cf6fbd4cb9758aa5209cd44352f117dd}.png}

\noindent\sphinxincludegraphics{{41ac4839ae07c23aee2ac8c2d4ee87aba064a80bcb974241b3980d07553e0058}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
fixes the problem model fits data well

\end{itemize}


\section{modifying x offset, y intercept, period and amplitude}
\label{\detokenize{Week7/MachineLearningFunction:modifying-x-offset-y-intercept-period-and-amplitude}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test\PYGZus{}model}\PYG{p}{(}\PYG{n}{X}\PYG{o}{=}\PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{y}\PYG{p}{,} \PYG{n}{hidden\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{n}{epochs} \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{lr} \PYG{o}{=} \PYG{l+m+mf}{0.005}\PYG{p}{,} \PYG{n}{seed\PYGZus{}model} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{X\PYGZus{}scalers} \PYG{o}{=} \PYG{n}{X\PYGZus{}scalers}\PYG{p}{,} \PYG{n}{y\PYGZus{}scalers} \PYG{o}{=} \PYG{n}{y\PYGZus{}scalers}\PYG{p}{,} \PYG{n}{vary\PYGZus{}x\PYGZus{}offset}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{vary\PYGZus{}period}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{vary\PYGZus{}y\PYGZus{}intercept}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{vary\PYGZus{}amplitude}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Data preppared
losses
Epoch 199, Loss: 0.0021223679650574923
Model trained
Done!
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{58a64cb80c597636461a88a0a38788838ccfaa20c42b903d54ba8e7f28a239bb}.png}

\noindent\sphinxincludegraphics{{5499ffec522b12a89a856865c9a77a13c28d8dac0f3b46f9eaabb4a75deb7254}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Conclusion}
\label{\detokenize{Week7/MachineLearningFunction:conclusion}}
\sphinxAtStartPar
A MLP was sucessfully built which can deconvolve step functions. Future steps include blending this with the richardson lucy algorithm and then testing this on a broader range of functions. Prehaps building this code into a class would be more managable.







\renewcommand{\indexname}{Index}
\printindex
\end{document}